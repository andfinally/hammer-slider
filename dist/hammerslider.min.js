'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function HammerSlider(_this, options) {
  'use strict';

  // Main declarations

  var SLIDER = {
    contentWidth: undefined,
    container: undefined,
    slides: undefined,
    dotContainer: undefined,
    dots: undefined,
    slideData: undefined,
    transform: undefined,
    currentSlideIndex: undefined,
    lastSlideIndex: undefined,
    isLastSlide: undefined,
    currentDistance: undefined,
    eventListeners: undefined
  };

  // Default options
  var OPTIONS = {
    slideShow: false,
    slideInterval: 5000,
    slideSpeed: 1200,
    touchSpeed: 800,
    startSlide: 0,
    dragThreshold: 10,
    minimumDragDistance: 30,
    stopAfterInteraction: true,
    rewind: false,
    mouseDrag: false,
    dotContainer: undefined,
    beforeSlideChange: undefined,
    afterSlideChange: undefined,
    onSetup: undefined,
    classPrefix: 'c-slider'
  };

  // Merge user options into defaults
  options && mergeObjects(OPTIONS, options);

  // Class names
  var CLASSES = {
    container: OPTIONS.classPrefix + '__container',
    slide: OPTIONS.classPrefix + '__slide',
    dotContainer: OPTIONS.classPrefix + '__dots',
    dotItem: OPTIONS.classPrefix + '__dot',
    dotActiveClass: OPTIONS.classPrefix + '__dot--is-active',
    dragging: OPTIONS.classPrefix + '__container--is-dragging',
    mouseDrag: OPTIONS.classPrefix + '__container--mouse-drag-enabled'
  };

  function mergeObjects(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
    return target;
  }

  function getElementChildren(element, selector, all) {
    return element['querySelector' + (all ? 'All' : '')](selector);
  }

  function addEvent(element, event, func, bool) {
    element.addEventListener(event, func, !!bool);
    return { remove: function remove() {
        return element.removeEventListener(event, func, !!bool);
      } };
  }

  function addClass(element, className) {
    element.classList.add(className);
  }

  function removeClass(element, className) {
    element && element.classList.remove(className);
  }

  function forEachItem(array, callback, startIndex) {
    for (var i = startIndex || 0; i < array.length; i += 1) {
      var returnValue = callback(array[i], i);
      if (returnValue) return returnValue;
    }
    return false;
  }

  function getItemsAsArray(nodeList) {
    var returnArray = [];
    forEachItem(nodeList, function (item) {
      returnArray.push(item);
    });
    return returnArray;
  }

  function getSupportedProperty(property) {
    var prefixes = ['', 'webkit', 'moz', 'ms', 'o'];
    var div = document.createElement('div');

    return forEachItem(prefixes, function (prefix) {
      var formattedProperty = '' + (prefix ? '-' + prefix + '-' : '') + property;
      if (typeof div.style[formattedProperty] !== 'undefined') return formattedProperty;
    });
  }

  function getCurrentPosition() {
    var transform = window.getComputedStyle(SLIDER.container, null).getPropertyValue(SLIDER.transform);
    var transformType = transform.match('matrix3d') ? 12 : 4;
    return parseFloat(transform.split(',')[transformType]) / SLIDER.container.offsetWidth * 100;
  }

  function translate(element, value, threeD) {
    var type = threeD ? '3d' : 'X';
    element.style[SLIDER.transform] = 'translate' + type + '(' + value + '%' + (threeD ? ',0,0' : '') + ')';
    // return (value) => element.style[SLIDER.transform] = `translate${type}(${value}%${threeD ? ',0,0' : ''})`;
  }

  function setItemWidth(containerWidth) {
    return function (item, index) {
      var width = Math.round(item.element.offsetWidth / containerWidth * 100);
      return mergeObjects(item, { width: width });
    };
  }

  function setItemAlignment(alignment) {
    var align = {
      left: function left(width) {
        return 0;
      },
      center: function center(width) {
        return (100 - width) / 2;
      },
      right: function right(width) {
        return 100 - width;
      }
    };
    return alignment ? align[alignment] : align['center'];
  }

  function setDistanceToItem(alignItem) {
    return function (item, index, itemArray) {
      var distanceToThis = itemArray.reduce(function (accumulator, innerItem, innerIndex) {
        if (innerIndex > index) return accumulator + 0;
        return accumulator + (innerIndex === index ? alignItem(innerItem.width) : -innerItem.width);
      }, 0);
      return mergeObjects(item, { distanceToThis: distanceToThis });
    };
  }

  function setDistanceBetweenItems(lastItemIndex) {
    return function (item, index, itemArray) {
      var nextItemIndex = !index ? lastItemIndex : index - 1;
      var distanceToNext = itemArray[nextItemIndex].distanceToThis - item.distanceToThis;
      return mergeObjects(item, { distanceToNext: distanceToNext });
    };
  }

  function setItemDistanceToFlip(itemArray) {
    return function (item) {
      var distanceToFlip = itemArray.reduce(function (accumulator, innerItem) {
        return accumulator + innerItem.width / item.width * 100;
      }, 0);
      return mergeObjects(item, { distanceToFlip: distanceToFlip });
    };
  }

  function setSlideData(container, slides, lastSlideIndex) {
    // Gather calculations
    var setSlideWidth = setItemWidth(container.offsetWidth);
    var setDistanceToSlide = setDistanceToItem(setItemAlignment(OPTIONS.slideAlign));
    var setDistanceBetweenSlides = setDistanceBetweenItems(lastSlideIndex);

    // Copy items & make calculations
    var slideData = [].concat(_toConsumableArray(slides)).map(function (slide) {
      return { element: slide };
    }).map(setSlideWidth).map(setDistanceToSlide).map(setDistanceBetweenSlides);

    // Infinite sliding specific calculations
    if (!OPTIONS.rewind) {
      var firstSlide = slideData[0];
      var lastSlide = slideData[lastSlideIndex];
      var setSlideDistanceToFlip = setItemDistanceToFlip(slideData);

      SLIDER.contentWidth = slideData.reduce(function (accumulator, slide) {
        return accumulator + slide.width;
      }, 0);
      firstSlide.distanceToNext += SLIDER.contentWidth;
      [firstSlide, lastSlide].map(setSlideDistanceToFlip);
    }
    return slideData;
  }

  function flip(position, direction) {
    /* Clean this mess the HELL up */
    if (direction === 1) {
      if (position < SLIDER.slideData[SLIDER.lastSlideIndex - 2].distanceToThis - SLIDER.slideData[SLIDER.lastSlideIndex - 2].width / 2) {
        translate(SLIDER.slides[SLIDER.lastSlideIndex], 0);
      }

      if (position < SLIDER.slideData[SLIDER.lastSlideIndex - 1].distanceToThis - SLIDER.slideData[SLIDER.lastSlideIndex - 1].width / 2) {
        translate(SLIDER.slides[0], SLIDER.slideData[0].distanceToFlip);
      }

      if (position < SLIDER.slideData[SLIDER.lastSlideIndex].distanceToThis - SLIDER.slideData[SLIDER.lastSlideIndex].width / 2) {
        translate(SLIDER.slides[0], 0);
        translate(SLIDER.slides[SLIDER.lastSlideIndex], SLIDER.slideData[SLIDER.lastSlideIndex].distanceToFlip * -1);
        return true;
      }
    } else {
      if (position > SLIDER.slideData[SLIDER.lastSlideIndex - 2].distanceToThis - SLIDER.slideData[SLIDER.lastSlideIndex - 2].width / 2) {
        translate(SLIDER.slides[SLIDER.lastSlideIndex], SLIDER.slideData[SLIDER.lastSlideIndex].distanceToFlip * -1);
      }

      if (position > SLIDER.slideData[SLIDER.lastSlideIndex - 1].distanceToThis - SLIDER.slideData[SLIDER.lastSlideIndex - 1].width / 2) {
        translate(SLIDER.slides[0], 0);
      }

      if (position > SLIDER.slideData[0].distanceToThis + SLIDER.slideData[0].width / 2) {
        translate(SLIDER.slides[0], SLIDER.slideData[0].distanceToFlip);
        translate(SLIDER.slides[SLIDER.lastSlideIndex], 0);
        return true;
      }
    }
  }

  function isLastItemIndex(lastIndex) {
    return function (index) {
      return index === lastIndex;
    };
  }

  function getNextItemIndex(currentItemIndex, direction) {
    if (direction === 1) {
      if (SLIDER.isLastSlide(currentItemIndex)) return 0;
    } else if (!currentItemIndex) {
      return SLIDER.lastSlideIndex;
    }
    return currentItemIndex + direction;
  }

  function slideTo(direction, jumpTo) {
    /* Clean this mess the HELL up */
    var currentSlideIndex = void 0;
    var currentDistance = void 0;

    if (typeof jumpTo === 'undefined') {
      currentSlideIndex = getNextItemIndex(SLIDER.currentSlideIndex, direction);
      var index = currentSlideIndex + 1 > SLIDER.lastSlideIndex ? 0 : currentSlideIndex + 1;
      var distance = direction === 1 ? SLIDER.slideData[currentSlideIndex].distanceToNext : SLIDER.slideData[index].distanceToNext;
      currentDistance = SLIDER.currentDistance - distance * direction;
    } else {
      direction = jumpTo - SLIDER.currentSlideIndex > 0 ? 1 : -1;
      currentSlideIndex = jumpTo;
      currentDistance = SLIDER.slideData[jumpTo].distanceToThis;
    }

    mergeObjects(SLIDER, { currentSlideIndex: currentSlideIndex, currentDistance: currentDistance });
    if (OPTIONS.beforeSlideChange) OPTIONS.beforeSlideChange(currentSlideIndex);

    stopSlideshow();
    setActiveDot(currentSlideIndex);
    animate(currentDistance, direction);
  }

  function animate(slideDistance, direction) {
    /* Clean this mess the HELL up */
    var slideSpeed = OPTIONS.slideSpeed,
        currPos = getCurrentPosition(),
        start = currPos,
        change = slideDistance - start,
        currentTime = 0,
        increment = 20;

    function render() {
      // Sliding ended
      if (currentTime > slideSpeed) {}
      //shouldResumeSlideshow(autoSlide);
      //OPTIONS.afterSlideChange && OPTIONS.afterSlideChange();

      // Else
      else {
          if (flip(currPos, direction)) {
            SLIDER.currentDistance += SLIDER.contentWidth * direction;
            start += SLIDER.contentWidth * direction;
          }
          currPos = easeOutQuint(currentTime, start, change, slideSpeed);
          currentTime += increment;
          translate(SLIDER.container, currPos, true);
          SLIDER.animationFrame = requestAnimationFrame(render);
        }
    }
    SLIDER.animationFrame = requestAnimationFrame(render);
  }

  function easeOutQuint(t, b, c, d) {
    t /= d;
    t--;
    return c * (t * t * t * t * t + 1) + b;
  };

  function startSlideshow() {
    mergeObjects(SLIDER, {
      autoTimeOut: setTimeout(function () {
        return slideTo(1);
      }, OPTIONS.slideInterval)
    });
  }

  function stopSlideshow() {
    cancelAnimationFrame(SLIDER.animationFrame);
    clearTimeout(SLIDER.autoTimeOut);
  }

  function shouldResumeSlideshow(autoSlide) {
    if (OPTIONS.slideShow && !OPTIONS.stopAfterInteraction || autoSlide) startSlideshow();
  }

  function setActiveDot(index) {
    if (OPTIONS.dots) {
      removeClass(getElementChildren(SLIDER.dotContainer, '.' + CLASSES.dotActiveClass), CLASSES.dotActiveClass);
      addClass(SLIDER.dots[index], CLASSES.dotActiveClass);
    }
  }

  function onWidthChange() {}
  // update slider width
  //stopSlideshow();
  //shouldResumeSlideshow();


  /*function touchInit() {
    let startPos,
      currPos,
      currentSlide;
     TouchEvents(SLIDER.container, {
      mouse: OPTIONS.mouseDrag,
      dragThreshold: OPTIONS.dragThreshold,
      // Pass touch state actions
      start: (event) => {
        stopSlideshow();
        startPos = getCurrentPosition() / SLIDER.container.offsetWidth * 100;
        currentSlide = slideIndex % nrOfSlides;
        // Add drag class
        addClass(SLIDER.container, CLASSES.dragging);
      },
      move: (event, direction, diff) => {
        if (direction === 'left' || direction === 'right') {
          const horizontalDiff = diff.X / SLIDER.container.offsetWidth * 100;
          // Calculate changed position
          currPos = startPos + horizontalDiff;
           if (!OPTIONS.rewind) {
            flip(currPos, direction === 'left' ? 1 : -1);
          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {
            // Resist dragging if it's first slide
            // or last and if rewind is true
            currPos = startPos + (diff.X / 2.5);
          }
          translate(SLIDER.container, currPos);
        }
      },
      end: (event, direction, diff) => {
        let targetSlide = slideIndex;
         // Only set new target slide if drag exceeds minimum drag distance
        if (Math.abs(diff.X) > OPTIONS.minimumDragDistance) {
          if (direction === 'left') {
            targetSlide = OPTIONS.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);
          } else if (direction === 'right') {
            targetSlide = OPTIONS.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);
          }
        }
        slideTo(targetSlide, false, OPTIONS.touchSpeed);
        // Remove drag class
        removeClass(SLIDER.container, CLASSES.dragging);
      }
    });
  }*/

  // Split into two funcs
  function setItemClickAndEnterEvent() {
    return function (item, index) {
      addEvent(dot, 'click', function (e) {
        return slideTo(false, nr);
      });
      addEvent(dot, 'keyup', function (e) {
        return e.keyCode === 13 && slideTo(false, nr);
      });
      return item;
    };
  }

  function setItemFocusEvent(element) {
    return function (item, index) {
      return addEvent(item, 'focus', function (e) {
        stopSlideshow();
        element.scrollLeft = 0;
        slideTo(false, index);
      }, true);
    };
  }

  function setupSlider(element, startIndex) {
    // Setup slide variables
    var container = getElementChildren(element, '.' + CLASSES.container);
    var slides = getItemsAsArray(getElementChildren(container, '.' + CLASSES.slide, true));
    var dotContainer = OPTIONS.dotContainer || getElementChildren(element, '.' + CLASSES.dotContainer);
    var dots = getItemsAsArray(getElementChildren(dotContainer, '.' + CLASSES.dotItem, true));
    var currentSlideIndex = startIndex;
    var lastSlideIndex = slides.length - 1;
    var isLastSlide = isLastItemIndex(lastSlideIndex);
    var slideData = setSlideData(container, slides, lastSlideIndex);
    var currentDistance = slideData[currentSlideIndex].distanceToThis;
    var transform = getSupportedProperty('transform');
    var setSlideFocusEvent = setItemFocusEvent(element);
    var eventListeners = slides.map(setSlideFocusEvent);

    // Bail if only one slide OR if transform is not supported
    if (!lastSlideIndex || !transform) return;

    // Merge variables into SLIDER
    mergeObjects(SLIDER, {
      container: container,
      slides: slides,
      dotContainer: dotContainer,
      dots: dots,
      slideData: slideData,
      transform: transform,
      currentSlideIndex: currentSlideIndex,
      lastSlideIndex: lastSlideIndex,
      isLastSlide: isLastSlide,
      currentDistance: currentDistance,
      eventListeners: eventListeners
    });

    // Set position and active dot
    translate(SLIDER.container, SLIDER.currentDistance);
    setActiveDot(SLIDER.currentSlideIndex);

    // Conditional actions
    if (!OPTIONS.rewind) {
      if (SLIDER.isLastSlide(SLIDER.currentSlideIndex)) translate(SLIDER.slides[0], SLIDER.slideData[0].distanceToFlip);
      if (!SLIDER.currentSlideIndex) translate(SLIDER.slides[SLIDER.lastSlideIndex], SLIDER.slideData[SLIDER.lastSlideIndex].distanceToFlip * -1);
    }

    if (OPTIONS.mouseDrag) addClass(SLIDER.container, CLASSES.mouseDrag);
    if (OPTIONS.slideShow) startSlideshow();

    // API Callback after setup, expose API first with timeout
    if (OPTIONS.onSetup) setTimeout(function () {
      return OPTIONS.onSetup(SLIDER.lastSlideIndex + 1);
    }, 0);
  }

  // Init
  setupSlider(_this, OPTIONS.startSlide);

  // Expose slider API
  return {
    next: function next() {
      return slideTo(1);
    },
    prev: function prev() {
      return slideTo(-1);
    },
    stop: stopSlideshow,
    start: startSlideshow
  };
}
'use strict';

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };

  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
})();
'use strict';

/*!
 * Event Burrito is a touch / mouse / pointer event unifier
 * https://github.com/wilddeer/Event-Burrito
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 *
 * NOTE: Event Burrito has been modified from
 * its original form to suit this project.
 */

/* exported TouchEvents */
function TouchEvents(_this, options) {
  'use strict';

  var touchStateCallback = function touchStateCallback() {},
      o = {
    preventDefault: true,
    clicksAllowed: true,
    mouse: true,
    dragThreshold: 10, // Minimum distance to determine swipe direction
    start: touchStateCallback,
    move: touchStateCallback,
    end: touchStateCallback
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  var start = {},
      diff = {},
      direction = void 0,
      eventType = void 0,
      axis = void 0,
      support = {
    pointerEvents: !!window.navigator.pointerEnabled,
    msPointerEvents: !!window.navigator.msPointerEnabled
  },
      eventModel = support.pointerEvents ? 1 : support.msPointerEvents ? 2 : 0,
      events = [['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events
  ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events
  ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events
  ['mousedown', 'mousemove', 'mouseup', false] //mouse events
  ],
      checks = [
  //touch events
  function (e) {
    //skip the event if it's multitouch or pinch move
    return e.touches && e.touches.length > 1 || e.scale && e.scale !== 1;
  },
  //pointer events
  function (e) {
    //Skip it, if:
    //1. event is not primary (other pointers during multitouch),
    //2. left mouse button is not pressed,
    //3. mouse drag is disabled and event is not touch
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen';
  },
  //IE10 pointer events
  function (e) {
    //same checks as in pointer events
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN;
  },
  //mouse events
  function (e) {
    //skip the event if left mouse button is not pressed
    //in IE7-8 `buttons` is not defined, in IE9 LMB is 0
    return e.buttons && e.buttons !== 1;
  }];

  function mergeObjects(targetObj, sourceObject) {
    for (var key in sourceObject) {
      if (sourceObject.hasOwnProperty(key)) {
        targetObj[key] = sourceObject[key];
      }
    }
  }

  function addEvent(el, event, func, bool) {
    if (!event) return;
    el.addEventListener(event, func, !!bool);
  }

  function removeEvent(el, event, func, bool) {
    if (!event) return;
    el.removeEventListener(event, func, !!bool);
  }

  function preventDefault(event) {
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
  }

  function getDiff(event) {
    diff = {
      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,
      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,
      time: new Date().getTime() - start.time
    };
  }

  function touchStart(event, type) {
    direction = '';
    o.clicksAllowed = true;
    eventType = type;

    if (checks[eventType](event)) return;
    if (preventDefault && eventType) preventDefault(event);

    addEvent(document, events[eventType][1], touchMove);
    addEvent(document, events[eventType][2], touchEnd);
    addEvent(document, events[eventType][3], touchEnd);

    start = {
      X: eventType ? event.clientX : event.touches[0].clientX,
      Y: eventType ? event.clientY : event.touches[0].clientY,
      time: new Date().getTime()
    };

    for (var key in diff) {
      diff[key] = 0;
    }
    o.start(event);
  }

  function touchMove(event) {
    getDiff(event);

    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.
    document['on' + events[eventType][1]] = function (e) {
      preventDefault(e);
    };

    if (!axis) {
      axis = o.dragThreshold < Math.abs(diff.X) ? 'X' : o.dragThreshold < Math.abs(diff.Y) ? 'Y' : false;
    } else {
      if (axis === 'X') {
        direction = diff.X < 0 ? 'left' : 'right';
        preventDefault && preventDefault(event);
      } else if (axis === 'Y') {
        direction = diff.Y < 0 ? 'up' : 'down';
      }
    }

    o.move(event, direction, diff);
  }

  function touchEnd(event) {
    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();

    removeEvent(document, events[eventType][1], touchMove);
    removeEvent(document, events[eventType][2], touchEnd);
    removeEvent(document, events[eventType][3], touchEnd);

    //Enable document scrolling
    document['on' + events[eventType][1]] = function (e) {
      return true;
    };

    o.end(event, direction, diff);
    axis = false;
  }

  function init() {
    // Bind touchstart
    addEvent(_this, events[eventModel][0], function (event) {
      touchStart(event, eventModel);
    });
    // Prevent stuff from dragging when using mouse
    addEvent(_this, 'dragstart', preventDefault);

    // Bind mousedown if necessary
    if (o.mouse && !eventModel) {
      addEvent(_this, events[3][0], function (event) {
        touchStart(event, 3);
      });
    }

    // No clicking during touch
    addEvent(_this, 'click', function (event) {
      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);
    });
  }

  // Init touch listeners
  init();
}
//# sourceMappingURL=hammerslider.min.js.map
