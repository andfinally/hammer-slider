'use strict';

function HammerSlider(_this, options) {
  'use strict';

  // Main declarations

  var slider = {
    width: undefined,
    contentWidth: undefined,
    slides: [],
    dots: []
  },
      slideData = [],
      currentDistance = 0,
      flipPoints = {},
      slideIndex = 0,
      nrOfSlides = 0,
      nrOfClones = 0,
      currentSlideNr = 0,
      prefixedTransform = void 0,
      u = void 0; // Utilities


  // Default options
  var o = {
    slideShow: false,
    slideInterval: 5000,
    slideSpeed: 1200,
    touchSpeed: 800,
    startSlide: 0,
    dragThreshold: 10,
    minimumDragDistance: 30,
    stopAfterInteraction: true,
    rewind: false,
    dots: false,
    mouseDrag: false,
    beforeSlideChange: undefined,
    afterSlideChange: undefined,
    onSetup: undefined,
    classPrefix: 'c-slider'
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  // Class names
  var classes = {
    dotWrap: o.classPrefix + '__dots',
    dotItem: o.classPrefix + '__dot',
    slide: o.classPrefix + '__slide',
    container: o.classPrefix + '__container',
    dotActiveClass: o.classPrefix + '__dot--is-active',
    dragging: o.classPrefix + '__container--is-dragging',
    mouseDrag: o.classPrefix + '__container--mouse-drag-enabled'
  };

  function mergeObjects(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
    return target;
  }

  function addEvent(el, event, func, bool) {
    el && el.addEventListener(event, func, !!bool);
  }

  function addClass(el, className) {
    el && el.classList.add(className);
  }

  function removeClass(el, className) {
    el && el.classList.remove(className);
  }

  function forEachItem(array, callback, startIndex) {
    for (var i = startIndex || 0; i < array.length; i += 1) {
      var returnValue = callback(array[i], i);
      if (returnValue) return returnValue;
    }
    return false;
  }

  function translate(el, value, threeD) {
    var type = threeD ? '3d' : 'X';
    el.style[prefixedTransform] = 'translate' + type + '(' + value + '%' + (threeD ? ',0,0' : '') + ')';
    // return (value) => el.style[prefixedTransform] = `translate${type}(${value}%${threeD ? ',0,0' : ''})`;
  }

  function getSupportedProperty(property) {
    var prefixes = ['', 'webkit', 'moz', 'ms', 'o'];
    var div = document.createElement('div');

    return forEachItem(prefixes, function (prefix) {
      var formattedProperty = '' + (prefix ? '-' + prefix + '-' : '') + property;
      if (typeof div.style[formattedProperty] !== 'undefined') return formattedProperty;
    });
  }

  function getCurrentPosition() {
    var transform = window.getComputedStyle(slider.container, null).getPropertyValue(prefixedTransform);
    var transformType = transform.match('matrix3d') ? 12 : 4;
    return parseFloat(transform.split(',')[transformType]) / slider.container.offsetWidth * 100;
  }

  function makeUtilities() {
    return {
      lastSlide: nrOfSlides - 1,
      isLastSlide: function isLastSlide(nr) {
        return nr === this.lastSlide;
      }
    };
  }

  function _setupSlider(startSlide) {
    var pos = startSlide || o.startSlide;
    slider.width = slider.container.offsetWidth;
    currentSlideNr = pos;

    if (!o.rewind) {}

    // Store items in slideData array
    slider.slides.forEach(function (slide) {
      return slideData.push({ item: slide });
    });

    // Calculate slide percentage widths
    slideData = slideData.map(function (slide) {
      var width = Math.round(slide.item.offsetWidth / slider.width * 100);
      return mergeObjects(slide, { width: width });
    });

    // Calculate slider container content percentage width
    slider.contentWidth = slideData.reduce(function (total, slide) {
      return total + slide.width;
    }, 0);

    // Calculate positions where slides are in middle of wrapper
    slideData = slideData.map(function (slide, number) {
      var distanceToThis = slideData.reduce(function (total, innerSlide, innerNumber) {
        if (innerNumber > number) return total + 0;
        return total + (innerNumber === number ? (100 - innerSlide.width) / 2 : -innerSlide.width);
      }, 0);
      return mergeObjects(slide, { distanceToThis: distanceToThis });
    });

    // Calculate distance diff between slide and it's next sibling
    slideData = slideData.map(function (slide, number) {
      var nextSlideNumber = !number ? nrOfSlides - 1 : number - 1;
      var lastSlideDistance = !number ? slider.contentWidth : 0;
      var distanceToNext = slideData[nextSlideNumber].distanceToThis - slide.distanceToThis + lastSlideDistance;

      return mergeObjects(slide, { distanceToNext: distanceToNext });
    });

    // Calculate flip to positions
    slideData = slideData.map(function (slide) {
      var flipTo = slideData.reduce(function (total, current) {
        return total + current.width / slide.width * 100;
      }, 0);
      return mergeObjects(slide, { flipTo: flipTo });
    });

    // Position slides
    if (!o.rewind) {
      if (u.isLastSlide(pos)) translate(slider.slides[0], slideData[0].flipTo);
      if (!pos) translate(slider.slides[nrOfSlides - 1], slideData[nrOfSlides - 1].flipTo * -1);
    }

    // Set slider start position and active dot
    translate(slider.container, slideData[pos].distanceToThis);
    currentDistance = slideData[pos].distanceToThis;
    setActiveDot(pos);

    /*
    flipPoints['1'] = {
      slide: nrOfSlides - 1,
      flipPoint: slideData[0].distanceToThis - slideData[0].width / 2,
      toPos: 0
    };
     flipPoints['-1'] = {
      slide: nrOfSlides - 2,
      flipPoint: slideData[0].width - slideData[0].distanceToThis,
      toPos: slideData[nrOfSlides - 2].flipTo * -1
    };
    */
  }

  /*function hasReachedFlipPoint(position) {
    const forwardFlip = flipPoints[1].flipPoint,
      backwardFlip = flipPoints[-1].flipPoint;
    // Return direction if forward or backward flip point has passed
    return position < forwardFlip ? 1 : position > backwardFlip ? -1 : false;
  }*/

  function flip(position, direction) {
    /* Clean this mess the HELL up */
    if (direction === 1) {
      if (position < slideData[nrOfSlides - 3].distanceToThis - slideData[nrOfSlides - 3].width / 2) {
        translate(slider.slides[nrOfSlides - 1], 0);
      }

      if (position < slideData[nrOfSlides - 2].distanceToThis - slideData[nrOfSlides - 2].width / 2) {
        translate(slider.slides[0], slideData[0].flipTo);
      }

      if (position < slideData[nrOfSlides - 1].distanceToThis - slideData[nrOfSlides - 1].width / 2) {
        translate(slider.slides[0], 0);
        translate(slider.slides[nrOfSlides - 1], slideData[nrOfSlides - 1].flipTo * -1);
        return true;
      }
    } else {
      if (position > slideData[nrOfSlides - 3].distanceToThis - slideData[nrOfSlides - 3].width / 2) {
        translate(slider.slides[nrOfSlides - 1], slideData[nrOfSlides - 1].flipTo * -1);
      }

      if (position > slideData[nrOfSlides - 2].distanceToThis - slideData[nrOfSlides - 2].width / 2) {
        translate(slider.slides[0], 0);
      }

      if (position > slideData[0].distanceToThis + slideData[0].width / 2) {
        translate(slider.slides[0], slideData[0].flipTo);
        translate(slider.slides[nrOfSlides - 1], 0);
        return true;
      }
    }
  }

  function getNextSlideNumber(slideNumber, direction) {
    if (direction > 0) {
      if (u.isLastSlide(slideNumber)) return 0;
    } else if (!slideNumber) {
      return u.lastSlide;
    }
    return slideNumber + direction;
  }

  function getSlideDistance(direction, jumpTo) {}

  function setPosition(direction, jumpTo) {
    var nextSlideNumber = void 0;
    var slideDistance = void 0;

    if (typeof jumpTo === 'undefined') {
      nextSlideNumber = getNextSlideNumber(currentSlideNr, direction);
      var index = nextSlideNumber + 1 > nrOfSlides - 1 ? 0 : nextSlideNumber + 1;
      var distance = direction === 1 ? slideData[nextSlideNumber].distanceToNext : slideData[index].distanceToNext;
      slideDistance = currentDistance - distance * direction;
    } else {
      direction = jumpTo - currentSlideNr > 0 ? 1 : -1;
      nextSlideNumber = jumpTo;
      slideDistance = slideData[jumpTo].distanceToThis;
    }

    currentDistance = slideDistance;
    currentSlideNr = nextSlideNumber;
    // API Callback
    //o.beforeSlideChange && o.beforeSlideChange(activeSlide);

    stopSlideshow();
    setActiveDot(currentSlideNr);
    slide(slideDistance, direction);
  }

  function slide(slideDistance, direction) {
    var slideSpeed = o.slideSpeed,
        currPos = getCurrentPosition(),
        start = currPos,
        change = slideDistance - start,
        currentTime = 0,
        increment = 20;

    function animate() {
      // Sliding ended
      if (currentTime > slideSpeed) {}
      //shouldResumeSlideshow(autoSlide);
      //o.afterSlideChange && o.afterSlideChange();

      // Else
      else {
          if (flip(currPos, direction)) {
            currentDistance += slider.contentWidth * direction;
            start += slider.contentWidth * direction;
          }

          currPos = easeOutQuint(currentTime, start, change, slideSpeed);
          currentTime += increment;
          translate(slider.container, currPos, true);
          slider.animationFrame = requestAnimationFrame(animate);
        }
    }
    slider.animationFrame = requestAnimationFrame(animate);
  }

  function easeOutQuint(t, b, c, d) {
    t /= d;
    t--;
    return c * (t * t * t * t * t + 1) + b;
  };

  function startSlideshow() {
    slider.autoTimeOut = setTimeout(function () {
      return setPosition(u.getNextSlideNr(1), false, false, true);
    }, o.slideInterval);
  }

  function stopSlideshow() {
    cancelAnimationFrame(slider.animationFrame);
    clearTimeout(slider.autoTimeOut);
  }

  function shouldResumeSlideshow(autoSlide) {
    (o.slideShow && !o.stopAfterInteraction || autoSlide) && startSlideshow();
  }

  function move(direction) {
    setPosition(direction);
  }

  function next() {
    move(1);
  }

  function prev() {
    move(-1);
  }

  function setActiveDot(active) {
    if (o.dots) {
      removeClass(slider.dotWrap.querySelector('.' + classes.dotActiveClass), classes.dotActiveClass);
      addClass(slider.dots[!nrOfClones ? active : Math.abs(slideIndex % (nrOfSlides - nrOfClones))], classes.dotActiveClass);
    }
  }

  function onWidthChange() {
    // update slider width
    //stopSlideshow();
    //shouldResumeSlideshow();
  }

  function touchInit() {
    var startPos = void 0,
        currPos = void 0,
        currentSlide = void 0;

    TouchEvents(slider.container, {
      mouse: o.mouseDrag,
      dragThreshold: o.dragThreshold,
      // Pass touch state actions
      start: function start(event) {
        stopSlideshow();
        startPos = getCurrentPosition() / slider.container.offsetWidth * 100;
        currentSlide = slideIndex % nrOfSlides;
        // Add drag class
        addClass(slider.container, classes.dragging);
      },
      move: function move(event, direction, diff) {
        if (direction === 'left' || direction === 'right') {
          var horizontalDiff = diff.X / slider.container.offsetWidth * 100;
          // Calculate changed position
          currPos = startPos + horizontalDiff;

          if (!o.rewind) {
            flip(currPos, direction === 'left' ? 1 : -1);
          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {
            // Resist dragging if it's first slide
            // or last and if rewind is true
            currPos = startPos + diff.X / 2.5;
          }
          translate(slider.container, currPos);
        }
      },
      end: function end(event, direction, diff) {
        var targetSlide = slideIndex;

        // Only set new target slide if drag exceeds minimum drag distance
        if (Math.abs(diff.X) > o.minimumDragDistance) {
          if (direction === 'left') {
            targetSlide = o.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);
          } else if (direction === 'right') {
            targetSlide = o.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);
          }
        }
        setPosition(targetSlide, false, o.touchSpeed);
        // Remove drag class
        removeClass(slider.container, classes.dragging);
      }
    });
  }

  function setup() {
    slider.container = _this.querySelector('.' + classes.container);
    var slides = slider.container.querySelectorAll('.' + classes.slide);
    forEachItem(slides, function (slide) {
      slider.slides.push(slide);
    });
    nrOfSlides = slider.slides.length;
    prefixedTransform = getSupportedProperty('transform');

    if (nrOfSlides < 2) return;

    // Make utilities
    u = makeUtilities();

    slider.slides.forEach(function (slide, number) {
      // Set focus event for slide
      addEvent(slide, 'focus', function (e) {
        stopSlideshow();
        _this.scrollLeft = 0;
        setPosition(false, number);
      }, true);
    });

    if (o.dots) {
      (function () {
        var dotFrag = document.createDocumentFragment();

        slider.slides.forEach(function (slide, number) {
          var newDot = document.createElement('li');

          (function (dot, nr) {
            addClass(dot, classes.dotItem);
            dot.setAttribute('tabindex', 0);
            dot.setAttribute('role', 'button');
            dot.innerHTML = '<span></span>';
            addEvent(dot, 'click', function (e) {
              return setPosition(false, nr);
            });
            addEvent(dot, 'keyup', function (e) {
              return e.keyCode === 13 && setPosition(false, nr);
            });
            dotFrag.appendChild(dot);
          })(newDot, number);

          // Cache dots
          slider.dots.push(newDot);

          // Add dots to slider or given dotContainer element
          if (u.isLastSlide(number)) {
            slider.dotWrap = o.dotContainer || document.createElement('ul');
            slider.dotWrap.appendChild(dotFrag);

            // Only add classname to dot container and
            // append it to slider if it's generated
            if (!o.dotContainer) {
              addClass(slider.dotWrap, classes.dotWrap);
              _this.appendChild(slider.dotWrap);
            }
          }
        });
      })();
    }

    // Listen for window resize events
    addEvent(window, 'resize', onWidthChange);
    addEvent(window, 'orientationchange', onWidthChange);

    // Listen for touch events
    //touchInit();
    _setupSlider();

    o.mouseDrag && addClass(slider.container, classes.mouseDrag);
    o.slideShow && startSlideshow();

    // API Callback after setup, expose API first with timeout
    o.onSetup && setTimeout(function () {
      return o.onSetup(nrOfSlides);
    }, 0);
  }

  // Init
  setup();

  // Expose slider API
  return {
    next: next,
    prev: prev,
    stop: stopSlideshow,
    start: startSlideshow,
    setupSlider: function setupSlider(slideNr) {
      return _setupSlider(slideNr);
    },
    moveTo: function moveTo(slideNr, speed) {
      return setPosition(slideNr, true, speed);
    }
  };
}
'use strict';

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };

  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
})();
'use strict';

/*!
 * Event Burrito is a touch / mouse / pointer event unifier
 * https://github.com/wilddeer/Event-Burrito
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 *
 * NOTE: Event Burrito has been modified from
 * its original form to suit this project.
 */

/* exported TouchEvents */
function TouchEvents(_this, options) {
  'use strict';

  var touchStateCallback = function touchStateCallback() {},
      o = {
    preventDefault: true,
    clicksAllowed: true,
    mouse: true,
    dragThreshold: 10, // Minimum distance to determine swipe direction
    start: touchStateCallback,
    move: touchStateCallback,
    end: touchStateCallback
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  var start = {},
      diff = {},
      direction = void 0,
      eventType = void 0,
      axis = void 0,
      support = {
    pointerEvents: !!window.navigator.pointerEnabled,
    msPointerEvents: !!window.navigator.msPointerEnabled
  },
      eventModel = support.pointerEvents ? 1 : support.msPointerEvents ? 2 : 0,
      events = [['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events
  ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events
  ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events
  ['mousedown', 'mousemove', 'mouseup', false] //mouse events
  ],
      checks = [
  //touch events
  function (e) {
    //skip the event if it's multitouch or pinch move
    return e.touches && e.touches.length > 1 || e.scale && e.scale !== 1;
  },
  //pointer events
  function (e) {
    //Skip it, if:
    //1. event is not primary (other pointers during multitouch),
    //2. left mouse button is not pressed,
    //3. mouse drag is disabled and event is not touch
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen';
  },
  //IE10 pointer events
  function (e) {
    //same checks as in pointer events
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN;
  },
  //mouse events
  function (e) {
    //skip the event if left mouse button is not pressed
    //in IE7-8 `buttons` is not defined, in IE9 LMB is 0
    return e.buttons && e.buttons !== 1;
  }];

  function mergeObjects(targetObj, sourceObject) {
    for (var key in sourceObject) {
      if (sourceObject.hasOwnProperty(key)) {
        targetObj[key] = sourceObject[key];
      }
    }
  }

  function addEvent(el, event, func, bool) {
    if (!event) return;
    el.addEventListener(event, func, !!bool);
  }

  function removeEvent(el, event, func, bool) {
    if (!event) return;
    el.removeEventListener(event, func, !!bool);
  }

  function preventDefault(event) {
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
  }

  function getDiff(event) {
    diff = {
      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,
      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,
      time: new Date().getTime() - start.time
    };
  }

  function touchStart(event, type) {
    direction = '';
    o.clicksAllowed = true;
    eventType = type;

    if (checks[eventType](event)) return;
    if (preventDefault && eventType) preventDefault(event);

    addEvent(document, events[eventType][1], touchMove);
    addEvent(document, events[eventType][2], touchEnd);
    addEvent(document, events[eventType][3], touchEnd);

    start = {
      X: eventType ? event.clientX : event.touches[0].clientX,
      Y: eventType ? event.clientY : event.touches[0].clientY,
      time: new Date().getTime()
    };

    for (var key in diff) {
      diff[key] = 0;
    }
    o.start(event);
  }

  function touchMove(event) {
    getDiff(event);

    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.
    document['on' + events[eventType][1]] = function (e) {
      preventDefault(e);
    };

    if (!axis) {
      axis = o.dragThreshold < Math.abs(diff.X) ? 'X' : o.dragThreshold < Math.abs(diff.Y) ? 'Y' : false;
    } else {
      if (axis === 'X') {
        direction = diff.X < 0 ? 'left' : 'right';
        preventDefault && preventDefault(event);
      } else if (axis === 'Y') {
        direction = diff.Y < 0 ? 'up' : 'down';
      }
    }

    o.move(event, direction, diff);
  }

  function touchEnd(event) {
    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();

    removeEvent(document, events[eventType][1], touchMove);
    removeEvent(document, events[eventType][2], touchEnd);
    removeEvent(document, events[eventType][3], touchEnd);

    //Enable document scrolling
    document['on' + events[eventType][1]] = function (e) {
      return true;
    };

    o.end(event, direction, diff);
    axis = false;
  }

  function init() {
    // Bind touchstart
    addEvent(_this, events[eventModel][0], function (event) {
      touchStart(event, eventModel);
    });
    // Prevent stuff from dragging when using mouse
    addEvent(_this, 'dragstart', preventDefault);

    // Bind mousedown if necessary
    if (o.mouse && !eventModel) {
      addEvent(_this, events[3][0], function (event) {
        touchStart(event, 3);
      });
    }

    // No clicking during touch
    addEvent(_this, 'click', function (event) {
      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);
    });
  }

  // Init touch listeners
  init();
}
//# sourceMappingURL=hammerslider.min.js.map
