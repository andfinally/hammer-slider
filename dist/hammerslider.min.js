'use strict';

function HammerSlider(_this, options) {
  'use strict';

  // Main declarations

  var slider = {
    slides: [],
    dots: []
  },
      slidePercentWidths = [],
      stopPositions = [],
      flipPoints = {},
      slideIndex = 0,
      nrOfSlides = 0,
      nrOfClones = 0,
      currentSlideNr = 0,
      prefixedTransform = void 0,
      u = void 0; // Utilities


  // Default options
  var o = {
    slideShow: false,
    slideInterval: 5000,
    slideSpeed: 50,
    touchSpeed: 50,
    startSlide: 0,
    dragThreshold: 10,
    minimumDragDistance: 30,
    stopAfterInteraction: true,
    rewind: false,
    dots: false,
    mouseDrag: false,
    dotContainer: undefined,
    slideContainer: undefined,
    beforeSlideChange: undefined,
    afterSlideChange: undefined,
    onSetup: undefined,
    cssPrefix: 'c-slider'
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  // Class names
  var classes = {
    dotWrap: o.cssPrefix + '__dots',
    dotItem: o.cssPrefix + '__dot',
    dotActiveClass: o.cssPrefix + '__dot--is-active',
    dragging: o.cssPrefix + '__container--is-dragging',
    mouseDrag: o.cssPrefix + '__container--mouse-drag-enabled'
  };

  function mergeObjects(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
  }

  function addEvent(el, event, func, bool) {
    el && el.addEventListener(event, func, !!bool);
  }

  function addClass(el, className) {
    el && el.classList.add(className);
  }

  function removeClass(el, className) {
    el && el.classList.remove(className);
  }

  function transform(el, value, type) {
    var translate = type || 'X';
    if (!type) {
      el.style[prefixedTransform] = 'translateX(' + value + '%)';
    } else {
      el.style[prefixedTransform] = 'translate3d(' + value + '%, 0, 0)';
    }
  }

  function getSupport(property) {
    var prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-'],
        div = document.createElement('div');

    for (var i in prefixes) {
      if (typeof div.style[prefixes[i] + property] !== 'undefined') {
        return prefixes[i] + property;
      }
    }
    return false;
  }

  function forEachSlide(callback) {
    // Pass slider object as context for "this" in loop since looping
    // slides will involve making changes to slider elements of some sort.
    for (var i = 0; i < nrOfSlides; i++) {
      callback.call(slider, i);
    }
  }

  function getCurrentPosition() {
    // Gets current translateX value for slider container.
    var transform = window.getComputedStyle(slider.container, null).getPropertyValue(prefixedTransform);
    var matrixType = transform.match('matrix3d') ? 12 : 4;

    return parseFloat(transform.split(',')[matrixType]);
  }

  function makeUtilities() {
    return {
      getNextSlideNr: o.rewind ? getNextRewindSlideNr : getNextSlideNr,
      getRelativeSlideNr: nrOfClones ? getRelativeCloneNr : getRelativeSlideNr,
      nrSlidesInPercent: nrOfSlides * 100,
      lastSlide: nrOfSlides - 1,
      isLastSlide: function isLastSlide(nr) {
        return nr === this.lastSlide;
      }
    };
  }

  function _setupSlider(startSlide) {
    var pos = startSlide ? Math.abs(startSlide) : o.startSlide;
    slideIndex = pos;
    currentSlideNr = pos;
    slider.width = _this.offsetWidth;

    if (!o.rewind) {
      // Flip points will be the breakpoints for slide flipping used to make
      // an infinite carousel effect. Flip points will always be set halfway
      // through a slide transition to get rid of flicking when slide speed is
      // not fast enough to hide it. 1 is forward and -1 is backward.
      flipPoints['1'] = {
        slide: !pos ? u.lastSlide : 0,
        flipPoint: (u.isLastSlide(pos) ? pos - 1 : pos) * (100 / nrOfSlides) * -1 + 100 / nrOfSlides * -0.5,
        toPos: !pos ? 0 : u.nrSlidesInPercent
      };

      flipPoints['-1'] = {
        slide: u.isLastSlide(pos) ? 0 : !pos ? u.lastSlide - 1 : u.lastSlide,
        flipPoint: pos * (100 / nrOfSlides) * -1 + 100 / nrOfSlides * 0.5,
        toPos: u.isLastSlide(pos) ? 0 : u.nrSlidesInPercent * -1
      };
    }

    var slideWidths = [];

    forEachSlide(function (i) {
      var slideWidth = Math.round(this.slides[i].offsetWidth / _this.offsetWidth * 100) / 100; // round to two decimals
      slideWidths.push(slideWidth * 100);

      var slidePosition = 0;

      if (!o.rewind) {
        // Position slides so there's always one slide before current
        // and one after for the infinite carousel effect.
        if (!i && u.isLastSlide(pos)) {
          slidePosition = u.nrSlidesInPercent;
        } else if (u.isLastSlide(i) && !pos) {
          slidePosition = u.nrSlidesInPercent * -1;
        }
      }

      this.slides[i].style.width = 100 / nrOfSlides + '%';
      transform(this.slides[i], slidePosition);

      setActiveDot(pos);
    });

    var totalWidth = slideWidths.reduce(function (prevWidth, currentWidth) {
      return prevWidth + currentWidth;
    });
    slider.container.style.width = totalWidth + '%';

    var containerWidthOfWrapper = 100 / totalWidth * 100;

    // Calculate stopPositions
    var totalPosition = 0;
    forEachSlide(function (i) {
      var baseSlidePosition = containerWidthOfWrapper - 100 / nrOfSlides;
      var finalPosition = baseSlidePosition / 2;

      if (i > 0) {
        totalPosition -= 100 / nrOfSlides;
      } else {
        totalPosition = finalPosition;
      }

      stopPositions.push(totalPosition);
    });

    transform(slider.container, stopPositions[pos], '3d');
  }

  function hasReachedFlipPoint(position) {
    var forwardFlip = flipPoints[1].flipPoint,
        backwardFlip = flipPoints[-1].flipPoint;
    // Return direction if forward or backward flip point has passed
    return position < forwardFlip ? 1 : position > backwardFlip ? -1 : false;
  }

  function flip(direction) {
    if (!direction) return;

    var opposite = direction > 0 ? -1 : 1,
        currFlip = flipPoints[direction];

    transform(slider.slides[currFlip.slide], currFlip.toPos);
    mergeObjects(flipPoints[opposite], {
      flipPoint: currFlip.flipPoint,
      slide: currFlip.slide,
      toPos: currFlip.toPos + u.nrSlidesInPercent * opposite
    });
    currFlip.flipPoint += 100 / nrOfSlides * opposite;

    if (updateFlipSlide(currFlip, direction)) {
      currFlip.toPos += u.nrSlidesInPercent * direction;
    }
  }

  function updateFlipSlide(obj, direction) {
    switch (direction) {
      case 1:
        obj.slide = u.isLastSlide(obj.slide) ? 0 : ++obj.slide;
        return !obj.slide;
      case -1:
        obj.slide = !obj.slide ? u.lastSlide : --obj.slide;
        return u.isLastSlide(obj.slide);
    }
  }

  function getNextSlideNr(direction) {
    return slideIndex + direction;
  }

  function getNextRewindSlideNr(direction) {
    // Change direction if rewind is true and it's the first
    // slide moving backward or last slide moving forward.
    if (direction > 0) {
      if (u.isLastSlide(currentSlideNr)) {
        return 0;
      }
    } else if (!currentSlideNr) {
      return u.lastSlide;
    }
    // Default: move to given direction
    return currentSlideNr + direction;
  }

  function getRelativeSlideNr(slideNr) {
    // To get next slide number relative to current position the offset from
    // base position needs to be calculated, since flipping slides causes
    // offsets for slideIndex when the infinite carousel effect is used.
    var currPos = getCurrentPosition(),
        currIndex = Math.ceil(currPos / slider.width),
        offsetCount = Math.ceil(currIndex / nrOfSlides),
        next = Math.abs(offsetCount * nrOfSlides - slideNr);

    return currPos > 0 ? next * -1 : next;
  }

  function getRelativeCloneNr(slideNr) {
    var currPos = getCurrentPosition() / slider.width,
        currIndex = currPos < 0 ? Math.ceil(Math.abs(currPos)) : Math.floor(currPos * -1),
        isEven = !(Math.abs(currIndex % nrOfSlides) % 2),
        next = isEven && slideNr ? 1 : !isEven && !slideNr ? -1 : 0;

    return currIndex + next;
  }

  function setPosition(nextSlide, relative) {
    var next = relative ? u.getRelativeSlideNr(nextSlide) : nextSlide;

    // Stop slideshow whenever interaction has occured before taking action.
    stopSlideshow();

    var slideDistance = next * (100 / nrOfSlides) * -1 + stopPositions[0];
    slideIndex = next;
    // API Callback
    //o.beforeSlideChange && o.beforeSlideChange(activeSlide);

    slide(slideDistance);
  }

  var addToPosition = false;
  var subtractPosition = false;

  function slide(slideDistance) {
    var slideSpeed = o.slideSpeed,
        currPos = getCurrentPosition() / slider.container.offsetWidth * 100,
        start = currPos,
        change = slideDistance - start,
        currentTime = 0,
        increment = 20;

    function animate() {
      // Sliding ended
      if (currentTime > slideSpeed) {}
      //setupSlider(currentSlideNr);
      //shouldResumeSlideshow(autoSlide);
      //o.afterSlideChange && o.afterSlideChange();

      // Else
      else {
          !o.rewind && flip(hasReachedFlipPoint(currPos));

          currPos = easeOutQuint(currentTime, start, change, slideSpeed);
          currentTime += increment;
          transform(slider.container, currPos, '3d');
          // Recursively call RAF until slide distance is met
          slider.animationFrame = requestAnimationFrame(animate);
        }
    }
    // Init RAF recursion
    slider.animationFrame = requestAnimationFrame(animate);
  }

  // try quint easing
  function easeOutQuint(t, b, c, d) {
    t /= d;
    t--;
    return c * (t * t * t * t * t + 1) + b;
  };

  function startSlideshow() {
    slider.autoTimeOut = setTimeout(function () {
      return setPosition(u.getNextSlideNr(1), false, false, true);
    }, o.slideInterval);
  }

  function stopSlideshow() {
    cancelAnimationFrame(slider.animationFrame);
    clearTimeout(slider.autoTimeOut);
  }

  function shouldResumeSlideshow(autoSlide) {
    (o.slideShow && !o.stopAfterInteraction || autoSlide) && startSlideshow();
  }

  function move(direction) {
    currentSlideNr = getNextRewindSlideNr(direction);
    setPosition(u.getNextSlideNr(direction));
  }

  function next() {
    move(1);
  }

  function prev() {
    move(-1);
  }

  function setActiveDot(active) {
    if (o.dots) {
      removeClass(slider.dotWrap.querySelector('.' + classes.dotActiveClass), classes.dotActiveClass);
      addClass(slider.dots[!nrOfClones ? active : Math.abs(slideIndex % (nrOfSlides - nrOfClones))], classes.dotActiveClass);
    }
  }

  function onWidthChange() {
    //stopSlideshow();
    //shouldResumeSlideshow();
  }

  function touchInit() {
    var startPos = void 0,
        currPos = void 0,
        currentSlide = void 0;

    TouchEvents(slider.container, {
      mouse: o.mouseDrag,
      dragThreshold: o.dragThreshold,
      // Pass touch state actions
      start: function start(event) {
        stopSlideshow();
        startPos = getCurrentPosition() / slider.container.offsetWidth * 100;
        currentSlide = slideIndex % nrOfSlides;
        // Add drag class
        addClass(slider.container, classes.dragging);
      },
      move: function move(event, direction, diff) {
        if (direction === 'left' || direction === 'right') {
          var horizontalDiff = diff.X / slider.container.offsetWidth * 100;
          // Calculate changed position
          currPos = startPos + horizontalDiff;

          if (!o.rewind) {
            flip(hasReachedFlipPoint(currPos));
          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {
            // Resist dragging if it's first slide
            // or last and if rewind is true
            currPos = startPos + diff.X / 2.5;
          }
          transform(slider.container, currPos);
        }
      },
      end: function end(event, direction, diff) {
        var targetSlide = slideIndex;

        // Only set new target slide if drag exceeds minimum drag distance
        if (Math.abs(diff.X) > o.minimumDragDistance) {
          if (direction === 'left') {
            targetSlide = o.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);
          } else if (direction === 'right') {
            targetSlide = o.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);
          }
        }
        setPosition(targetSlide, false, o.touchSpeed);
        // Remove drag class
        removeClass(slider.container, classes.dragging);
      }
    });
  }

  function setup() {
    var dotFrag = document.createDocumentFragment();
    slider.container = o.slideContainer || _this.children[0];
    nrOfSlides = slider.container.children.length;
    prefixedTransform = getSupport('transform');

    // Only set widths if one slide is provided or
    // transform is not supported in browser and bail.
    if (nrOfSlides <= 1 || !prefixedTransform) {
      forEachSlide(function (i) {
        this.container.children[i].style.width = '100%';
        this.container.style.width = nrOfSlides * 100 + '%';
      });
      // Remove hardware acceleration if transform is supported
      prefixedTransform && transform(slider.container, 0);
      return;
    }

    // Special case: Add 2 clones if slider only has 2
    // slides and the infinite carousel effect is used.
    if (!o.rewind && nrOfSlides === 2) {
      var container = slider.container,
          children = container.children;
      container.appendChild(children[0].cloneNode(1));
      container.appendChild(children[nrOfSlides - 1].cloneNode(1));
      nrOfSlides += 2;
      nrOfClones = 2;
    }

    // Make utilities
    u = makeUtilities();
    // Round slide speed to nearest 10th to work with raf animation loop design
    o.slideSpeed = o.slideSpeed < 2 ? 2 : Math.ceil(o.slideSpeed / 10) * 10;

    forEachSlide(function (i) {
      // Cache slides
      this.slides.push(this.container.children[i]);

      // Prevent slider from breaking when tabbing during slide
      // transition which alters scrollLeft. Set scrollLeft to
      // 0 and slide to focused slide instead.
      addEvent(this.slides[i], 'focus', function (e) {
        stopSlideshow();
        _this.scrollLeft = 0;
        setPosition(i);
      }, true);

      if (o.dots) {
        var newDot = document.createElement('li');

        (function (dot, nr) {
          // Don't create dots for clones
          if (nr >= nrOfSlides - nrOfClones) return;

          // Make dots tabbable with "tabindex"
          addClass(dot, classes.dotItem);
          dot.setAttribute('tabindex', 0);
          dot.setAttribute('role', 'button');

          dot.innerHTML = '<span></span>';

          // Remove outlines from dots when clicked
          addEvent(dot, 'click', function (e) {
            setPosition(nr, true);
            //dot.blur();
          });

          // Don't remove outlines when tabbing and Enter
          // key is used to navigate with dots.
          addEvent(dot, 'keyup', function (e) {
            e.keyCode === 13 && setPosition(nr, true);
          });

          dotFrag.appendChild(dot);
        })(newDot, i);

        // Cache dots
        this.dots.push(newDot);

        // Add dots to slider or given dotContainer element
        if (u.isLastSlide(i)) {
          this.dotWrap = o.dotContainer || document.createElement('ul');
          this.dotWrap.appendChild(dotFrag);

          // Only add classname to dot container and
          // append it to slider if it's generated
          if (!o.dotContainer) {
            addClass(this.dotWrap, classes.dotWrap);
            _this.appendChild(this.dotWrap);
          }
        }
      }
    });

    // Listen for window resize events
    addEvent(window, 'resize', onWidthChange);
    addEvent(window, 'orientationchange', onWidthChange);

    // Listen for touch events
    touchInit();
    _setupSlider();

    o.mouseDrag && addClass(slider.container, classes.mouseDrag);
    o.slideShow && startSlideshow();

    // API Callback after setup, expose API first with timeout
    o.onSetup && setTimeout(function () {
      return o.onSetup(nrOfSlides);
    }, 0);
  }

  // Init
  setup();

  // Expose slider API
  return {
    next: next,
    prev: prev,
    stop: stopSlideshow,
    start: startSlideshow,
    setupSlider: function setupSlider(slideNr) {
      return _setupSlider(slideNr);
    },
    moveTo: function moveTo(slideNr, speed) {
      return setPosition(slideNr, true, speed);
    }
  };
}
'use strict';

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };

  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
})();
'use strict';

/*!
 * Event Burrito is a touch / mouse / pointer event unifier
 * https://github.com/wilddeer/Event-Burrito
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 *
 * NOTE: Event Burrito has been modified from
 * its original form to suit this project.
 */

/* exported TouchEvents */
function TouchEvents(_this, options) {
  'use strict';

  var touchStateCallback = function touchStateCallback() {},
      o = {
    preventDefault: true,
    clicksAllowed: true,
    mouse: true,
    dragThreshold: 10, // Minimum distance to determine swipe direction
    start: touchStateCallback,
    move: touchStateCallback,
    end: touchStateCallback
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  var start = {},
      diff = {},
      direction = void 0,
      eventType = void 0,
      axis = void 0,
      support = {
    pointerEvents: !!window.navigator.pointerEnabled,
    msPointerEvents: !!window.navigator.msPointerEnabled
  },
      eventModel = support.pointerEvents ? 1 : support.msPointerEvents ? 2 : 0,
      events = [['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events
  ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events
  ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events
  ['mousedown', 'mousemove', 'mouseup', false] //mouse events
  ],
      checks = [
  //touch events
  function (e) {
    //skip the event if it's multitouch or pinch move
    return e.touches && e.touches.length > 1 || e.scale && e.scale !== 1;
  },
  //pointer events
  function (e) {
    //Skip it, if:
    //1. event is not primary (other pointers during multitouch),
    //2. left mouse button is not pressed,
    //3. mouse drag is disabled and event is not touch
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen';
  },
  //IE10 pointer events
  function (e) {
    //same checks as in pointer events
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN;
  },
  //mouse events
  function (e) {
    //skip the event if left mouse button is not pressed
    //in IE7-8 `buttons` is not defined, in IE9 LMB is 0
    return e.buttons && e.buttons !== 1;
  }];

  function mergeObjects(targetObj, sourceObject) {
    for (var key in sourceObject) {
      if (sourceObject.hasOwnProperty(key)) {
        targetObj[key] = sourceObject[key];
      }
    }
  }

  function addEvent(el, event, func, bool) {
    if (!event) return;
    el.addEventListener(event, func, !!bool);
  }

  function removeEvent(el, event, func, bool) {
    if (!event) return;
    el.removeEventListener(event, func, !!bool);
  }

  function preventDefault(event) {
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
  }

  function getDiff(event) {
    diff = {
      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,
      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,
      time: new Date().getTime() - start.time
    };
  }

  function touchStart(event, type) {
    direction = '';
    o.clicksAllowed = true;
    eventType = type;

    if (checks[eventType](event)) return;
    if (preventDefault && eventType) preventDefault(event);

    addEvent(document, events[eventType][1], touchMove);
    addEvent(document, events[eventType][2], touchEnd);
    addEvent(document, events[eventType][3], touchEnd);

    start = {
      X: eventType ? event.clientX : event.touches[0].clientX,
      Y: eventType ? event.clientY : event.touches[0].clientY,
      time: new Date().getTime()
    };

    for (var key in diff) {
      diff[key] = 0;
    }
    o.start(event);
  }

  function touchMove(event) {
    getDiff(event);

    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.
    document['on' + events[eventType][1]] = function (e) {
      preventDefault(e);
    };

    if (!axis) {
      axis = o.dragThreshold < Math.abs(diff.X) ? 'X' : o.dragThreshold < Math.abs(diff.Y) ? 'Y' : false;
    } else {
      if (axis === 'X') {
        direction = diff.X < 0 ? 'left' : 'right';
        preventDefault && preventDefault(event);
      } else if (axis === 'Y') {
        direction = diff.Y < 0 ? 'up' : 'down';
      }
    }

    o.move(event, direction, diff);
  }

  function touchEnd(event) {
    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();

    removeEvent(document, events[eventType][1], touchMove);
    removeEvent(document, events[eventType][2], touchEnd);
    removeEvent(document, events[eventType][3], touchEnd);

    //Enable document scrolling
    document['on' + events[eventType][1]] = function (e) {
      return true;
    };

    o.end(event, direction, diff);
    axis = false;
  }

  function init() {
    // Bind touchstart
    addEvent(_this, events[eventModel][0], function (event) {
      touchStart(event, eventModel);
    });
    // Prevent stuff from dragging when using mouse
    addEvent(_this, 'dragstart', preventDefault);

    // Bind mousedown if necessary
    if (o.mouse && !eventModel) {
      addEvent(_this, events[3][0], function (event) {
        touchStart(event, 3);
      });
    }

    // No clicking during touch
    addEvent(_this, 'click', function (event) {
      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);
    });
  }

  // Init touch listeners
  init();
}
//# sourceMappingURL=hammerslider.min.js.map
