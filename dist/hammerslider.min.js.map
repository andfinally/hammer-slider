{"version":3,"sources":["hammerslider.js","raf-polyfill.js","touch-events.js"],"names":["HammerSlider","_this","options","slider","slides","dots","slidePercentWidths","stopPositions","flipPoints","slideIndex","nrOfSlides","nrOfClones","currentSlideNr","prefixedTransform","u","o","slideShow","slideInterval","slideSpeed","touchSpeed","startSlide","dragThreshold","minimumDragDistance","stopAfterInteraction","rewind","mouseDrag","dotContainer","undefined","slideContainer","beforeSlideChange","afterSlideChange","onSetup","cssPrefix","mergeObjects","classes","dotWrap","dotItem","dotActiveClass","dragging","target","source","key","hasOwnProperty","addEvent","el","event","func","bool","addEventListener","addClass","className","classList","add","removeClass","remove","transform","value","type","translate","style","getSupport","property","prefixes","div","document","createElement","i","forEachSlide","callback","call","getCurrentPosition","window","getComputedStyle","container","getPropertyValue","matrixType","match","parseFloat","split","makeUtilities","getNextSlideNr","getNextRewindSlideNr","getRelativeSlideNr","getRelativeCloneNr","nrSlidesInPercent","lastSlide","isLastSlide","nr","setupSlider","pos","Math","abs","width","offsetWidth","slide","flipPoint","toPos","slideWidths","slideWidth","round","push","slidePosition","setActiveDot","totalWidth","reduce","prevWidth","currentWidth","containerWidthOfWrapper","totalPosition","baseSlidePosition","finalPosition","hasReachedFlipPoint","position","forwardFlip","backwardFlip","flip","direction","opposite","currFlip","updateFlipSlide","obj","slideNr","currPos","currIndex","ceil","offsetCount","next","floor","isEven","setPosition","nextSlide","relative","stopSlideshow","slideDistance","addToPosition","subtractPosition","start","change","currentTime","increment","animate","easeOutQuint","animationFrame","requestAnimationFrame","t","b","c","d","startSlideshow","autoTimeOut","setTimeout","cancelAnimationFrame","clearTimeout","shouldResumeSlideshow","autoSlide","move","prev","active","querySelector","onWidthChange","touchInit","startPos","currentSlide","TouchEvents","mouse","diff","horizontalDiff","X","end","targetSlide","setup","dotFrag","createDocumentFragment","children","length","appendChild","cloneNode","e","scrollLeft","newDot","dot","setAttribute","innerHTML","keyCode","stop","moveTo","speed","lastTime","vendors","x","element","currTime","Date","getTime","timeToCall","max","id","touchStateCallback","preventDefault","clicksAllowed","eventType","axis","support","pointerEvents","navigator","pointerEnabled","msPointerEvents","msPointerEnabled","eventModel","events","checks","touches","scale","isPrimary","buttons","pointerType","MSPOINTER_TYPE_TOUCH","MSPOINTER_TYPE_PEN","targetObj","sourceObject","removeEvent","removeEventListener","returnValue","getDiff","clientX","Y","clientY","time","touchStart","touchMove","touchEnd","blur","init"],"mappings":"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","file":"hammerslider.min.js","sourcesContent":["function HammerSlider(_this, options) {\n  'use strict';\n\n  // Main declarations\n  let slider = {\n      slides: [],\n      dots: []\n    },\n    slidePercentWidths = [],\n    stopPositions = [],\n    flipPoints = {},\n    slideIndex = 0,\n    nrOfSlides = 0,\n    nrOfClones = 0,\n    currentSlideNr = 0,\n    prefixedTransform,\n    u; // Utilities\n\n\n  // Default options\n  const o = {\n    slideShow: false,\n    slideInterval: 5000,\n    slideSpeed: 50,\n    touchSpeed: 50,\n    startSlide: 0,\n    dragThreshold: 10,\n    minimumDragDistance: 30,\n    stopAfterInteraction: true,\n    rewind: false,\n    dots: false,\n    mouseDrag: false,\n    dotContainer: undefined,\n    slideContainer: undefined,\n    beforeSlideChange: undefined,\n    afterSlideChange: undefined,\n    onSetup: undefined,\n    cssPrefix: 'c-slider'\n  };\n\n\n  // Merge user options into defaults\n  options && mergeObjects(o, options);\n\n\n  // Class names\n  const classes = {\n    dotWrap: `${o.cssPrefix}__dots`,\n    dotItem: `${o.cssPrefix}__dot`,\n    dotActiveClass: `${o.cssPrefix}__dot--is-active`,\n    dragging: `${o.cssPrefix}__container--is-dragging`,\n    mouseDrag: `${o.cssPrefix}__container--mouse-drag-enabled`\n  };\n\n\n  function mergeObjects(target, source) {\n    for (let key in source) {\n      if (source.hasOwnProperty(key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n\n  function addEvent(el, event, func, bool) {\n    el && el.addEventListener(event, func, !!bool);\n  }\n\n\n  function addClass(el, className) {\n    el && el.classList.add(className);\n  }\n\n\n  function removeClass(el, className) {\n    el && el.classList.remove(className);\n  }\n\n\n  function transform(el, value, type) {\n    const translate = type || 'X'\n    if (!type) {\n      el.style[prefixedTransform] = `translateX(${value}%)`;\n    } else {\n      el.style[prefixedTransform] = `translate3d(${value}%, 0, 0)`;\n    }\n\n  }\n\n\n  function getSupport(property) {\n    const prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-'],\n      div = document.createElement('div');\n\n    for (let i in prefixes) {\n      if (typeof div.style[prefixes[i] + property] !== 'undefined') {\n        return prefixes[i] + property;\n      }\n    }\n    return false;\n  }\n\n\n  function forEachSlide(callback) {\n    // Pass slider object as context for \"this\" in loop since looping\n    // slides will involve making changes to slider elements of some sort.\n    for (let i = 0; i < nrOfSlides; i++) {\n      callback.call(slider, i);\n    }\n  }\n\n\n  function getCurrentPosition() {\n    // Gets current translateX value for slider container.\n    const transform = window.getComputedStyle(slider.container, null).getPropertyValue(prefixedTransform);\n    const matrixType = transform.match('matrix3d') ? 12 : 4;\n\n    return parseFloat(transform.split(',')[matrixType]);\n  }\n\n\n  function makeUtilities() {\n    return {\n      getNextSlideNr: o.rewind ? getNextRewindSlideNr : getNextSlideNr,\n      getRelativeSlideNr: nrOfClones ? getRelativeCloneNr : getRelativeSlideNr,\n      nrSlidesInPercent: nrOfSlides * 100,\n      lastSlide: nrOfSlides - 1,\n      isLastSlide: function(nr) {\n        return nr === this.lastSlide;\n      }\n    };\n  }\n\n\n  function setupSlider(startSlide) {\n    const pos = startSlide ? Math.abs(startSlide) : o.startSlide;\n    slideIndex = pos;\n    currentSlideNr = pos;\n    slider.width = _this.offsetWidth;\n\n    if (!o.rewind) {\n      // Flip points will be the breakpoints for slide flipping used to make\n      // an infinite carousel effect. Flip points will always be set halfway\n      // through a slide transition to get rid of flicking when slide speed is\n      // not fast enough to hide it. 1 is forward and -1 is backward.\n      flipPoints['1'] = {\n        slide: !pos ? u.lastSlide : 0,\n        flipPoint: (u.isLastSlide(pos) ? pos - 1 : pos) * (100 / nrOfSlides) * -1 + (100 / nrOfSlides) * -0.5,\n        toPos: !pos ? 0 : u.nrSlidesInPercent\n      };\n\n      flipPoints['-1'] = {\n        slide: u.isLastSlide(pos) ? 0 : !pos ? u.lastSlide - 1 : u.lastSlide,\n        flipPoint: pos * (100 / nrOfSlides) * -1 + (100 / nrOfSlides) * 0.5,\n        toPos: u.isLastSlide(pos) ? 0 : u.nrSlidesInPercent * -1\n      };\n    }\n\n    const slideWidths = [];\n\n    forEachSlide(function(i) {\n      const slideWidth = Math.round((this.slides[i].offsetWidth / _this.offsetWidth) * 100) / 100; // round to two decimals\n      slideWidths.push(slideWidth * 100);\n\n      let slidePosition = 0;\n\n      if (!o.rewind) {\n        // Position slides so there's always one slide before current\n        // and one after for the infinite carousel effect.\n        if (!i && u.isLastSlide(pos)) {\n          slidePosition = u.nrSlidesInPercent;\n        } else if (u.isLastSlide(i) && !pos) {\n          slidePosition = u.nrSlidesInPercent * -1;\n        }\n      }\n\n      this.slides[i].style.width = `${100 / nrOfSlides}%`;\n      transform(this.slides[i], slidePosition);\n\n      setActiveDot(pos);\n    });\n\n    const totalWidth = slideWidths.reduce((prevWidth, currentWidth) => prevWidth + currentWidth);\n    slider.container.style.width = `${totalWidth}%`;\n\n    const containerWidthOfWrapper = (100 / totalWidth) * 100;\n\n    // Calculate stopPositions\n    let totalPosition = 0;\n    forEachSlide(function(i) {\n      const baseSlidePosition = containerWidthOfWrapper - (100 / nrOfSlides);\n      const finalPosition = baseSlidePosition / 2;\n\n      if (i > 0) {\n        totalPosition -= (100 / nrOfSlides);\n      } else {\n        totalPosition = finalPosition;\n      }\n\n      stopPositions.push(totalPosition);\n    });\n\n    transform(slider.container, stopPositions[pos], '3d');\n  }\n\n\n  function hasReachedFlipPoint(position) {\n    const forwardFlip = flipPoints[1].flipPoint,\n      backwardFlip = flipPoints[-1].flipPoint;\n    // Return direction if forward or backward flip point has passed\n    return position < forwardFlip ? 1 : position > backwardFlip ? -1 : false;\n  }\n\n\n  function flip(direction) {\n    if (!direction) return;\n\n    const opposite = direction > 0 ? -1 : 1,\n      currFlip = flipPoints[direction];\n\n    transform(slider.slides[currFlip.slide], currFlip.toPos);\n    mergeObjects(flipPoints[opposite], {\n      flipPoint: currFlip.flipPoint,\n      slide: currFlip.slide,\n      toPos: currFlip.toPos + u.nrSlidesInPercent * opposite\n    });\n    currFlip.flipPoint += (100 / nrOfSlides) * opposite;\n\n    if (updateFlipSlide(currFlip, direction)) {\n      currFlip.toPos += u.nrSlidesInPercent * direction;\n    }\n  }\n\n\n  function updateFlipSlide(obj, direction) {\n    switch (direction) {\n      case 1:\n        obj.slide = u.isLastSlide(obj.slide) ? 0 : ++obj.slide;\n        return !obj.slide;\n      case -1:\n        obj.slide = !obj.slide ? u.lastSlide : --obj.slide;\n        return u.isLastSlide(obj.slide);\n    }\n  }\n\n\n  function getNextSlideNr(direction) {\n    return slideIndex + direction;\n  }\n\n\n  function getNextRewindSlideNr(direction) {\n    // Change direction if rewind is true and it's the first\n    // slide moving backward or last slide moving forward.\n    if (direction > 0) {\n      if (u.isLastSlide(currentSlideNr)) {\n        return 0;\n      }\n    } else if (!currentSlideNr) {\n        return u.lastSlide;\n    }\n    // Default: move to given direction\n    return currentSlideNr + direction;\n  }\n\n\n  function getRelativeSlideNr(slideNr) {\n    // To get next slide number relative to current position the offset from\n    // base position needs to be calculated, since flipping slides causes\n    // offsets for slideIndex when the infinite carousel effect is used.\n    const currPos = getCurrentPosition(),\n      currIndex = Math.ceil(currPos / slider.width),\n      offsetCount = Math.ceil(currIndex / nrOfSlides),\n      next = Math.abs(offsetCount * nrOfSlides - slideNr);\n\n    return currPos > 0 ? next * -1 : next;\n  }\n\n\n  function getRelativeCloneNr(slideNr) {\n    const currPos = getCurrentPosition() / slider.width,\n      currIndex = (currPos < 0) ? Math.ceil(Math.abs(currPos)) : Math.floor(currPos * -1),\n      isEven = !(Math.abs(currIndex % nrOfSlides) % 2),\n      next = isEven && slideNr ? 1 : !isEven && !slideNr ? -1 : 0;\n\n    return currIndex + next;\n  }\n\n\n  function setPosition(nextSlide, relative) {\n    let next = relative ? u.getRelativeSlideNr(nextSlide) : nextSlide;\n\n    // Stop slideshow whenever interaction has occured before taking action.\n    stopSlideshow();\n\n\n    const slideDistance = next * (100 / nrOfSlides) * -1 + stopPositions[0];\n    slideIndex = next;\n    // API Callback\n    //o.beforeSlideChange && o.beforeSlideChange(activeSlide);\n\n    slide(slideDistance);\n  }\n\n\n  let addToPosition = false;\n  let subtractPosition = false;\n\n  function slide(slideDistance) {\n    let slideSpeed = o.slideSpeed,\n      currPos = getCurrentPosition() / slider.container.offsetWidth * 100,\n      start = currPos,\n      change = slideDistance - start,\n      currentTime = 0,\n      increment = 20;\n\n    function animate() {\n      // Sliding ended\n      if (currentTime > slideSpeed) {\n        //setupSlider(currentSlideNr);\n        //shouldResumeSlideshow(autoSlide);\n        //o.afterSlideChange && o.afterSlideChange();\n      }\n      // Else\n      else {\n        !o.rewind && flip(hasReachedFlipPoint(currPos));\n\n        currPos = easeOutQuint(currentTime, start, change, slideSpeed);\n        currentTime += increment;\n        transform(slider.container, currPos, '3d');\n        // Recursively call RAF until slide distance is met\n        slider.animationFrame = requestAnimationFrame(animate);\n      }\n    }\n    // Init RAF recursion\n    slider.animationFrame = requestAnimationFrame(animate);\n  }\n\n\n  // try quint easing\n  function easeOutQuint(t, b, c, d) {\n      t /= d;\n      t--;\n      return c*(t*t*t*t*t + 1) + b;\n  };\n\n\n  function startSlideshow() {\n    slider.autoTimeOut = setTimeout(() => setPosition(u.getNextSlideNr(1), false, false, true), o.slideInterval);\n  }\n\n\n  function stopSlideshow() {\n    cancelAnimationFrame(slider.animationFrame);\n    clearTimeout(slider.autoTimeOut);\n  }\n\n\n  function shouldResumeSlideshow(autoSlide) {\n    (o.slideShow && !o.stopAfterInteraction || autoSlide) && startSlideshow();\n  }\n\n\n  function move(direction) {\n    currentSlideNr = getNextRewindSlideNr(direction);\n    setPosition(u.getNextSlideNr(direction));\n  }\n\n\n  function next() {\n    move(1);\n  }\n\n\n  function prev() {\n    move(-1);\n  }\n\n\n  function setActiveDot(active) {\n    if (o.dots) {\n      removeClass(slider.dotWrap.querySelector(`.${classes.dotActiveClass}`), classes.dotActiveClass);\n      addClass(slider.dots[!nrOfClones ? active : Math.abs(slideIndex % (nrOfSlides - nrOfClones))], classes.dotActiveClass);\n    }\n  }\n\n\n  function onWidthChange() {\n    //stopSlideshow();\n    //shouldResumeSlideshow();\n  }\n\n\n  function touchInit() {\n    let startPos,\n      currPos,\n      currentSlide;\n\n    TouchEvents(slider.container, {\n      mouse: o.mouseDrag,\n      dragThreshold: o.dragThreshold,\n      // Pass touch state actions\n      start: (event) => {\n        stopSlideshow();\n        startPos = getCurrentPosition() / slider.container.offsetWidth * 100;\n        currentSlide = slideIndex % nrOfSlides;\n        // Add drag class\n        addClass(slider.container, classes.dragging);\n      },\n      move: (event, direction, diff) => {\n        if (direction === 'left' || direction === 'right') {\n          const horizontalDiff = diff.X / slider.container.offsetWidth * 100;\n          // Calculate changed position\n          currPos = startPos + horizontalDiff;\n\n          if (!o.rewind) {\n            flip(hasReachedFlipPoint(currPos));\n          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {\n            // Resist dragging if it's first slide\n            // or last and if rewind is true\n            currPos = startPos + (diff.X / 2.5);\n          }\n          transform(slider.container, currPos);\n        }\n      },\n      end: (event, direction, diff) => {\n        let targetSlide = slideIndex;\n\n        // Only set new target slide if drag exceeds minimum drag distance\n        if (Math.abs(diff.X) > o.minimumDragDistance) {\n          if (direction === 'left') {\n            targetSlide = o.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);\n          } else if (direction === 'right') {\n            targetSlide = o.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);\n          }\n        }\n        setPosition(targetSlide, false, o.touchSpeed);\n        // Remove drag class\n        removeClass(slider.container, classes.dragging);\n      }\n    });\n  }\n\n\n  function setup() {\n    const dotFrag = document.createDocumentFragment();\n    slider.container = o.slideContainer || _this.children[0];\n    nrOfSlides = slider.container.children.length;\n    prefixedTransform = getSupport('transform');\n\n    // Only set widths if one slide is provided or\n    // transform is not supported in browser and bail.\n    if (nrOfSlides <= 1 || !prefixedTransform) {\n      forEachSlide(function(i) {\n        this.container.children[i].style.width = '100%';\n        this.container.style.width = `${nrOfSlides * 100}%`;\n      });\n      // Remove hardware acceleration if transform is supported\n      prefixedTransform && transform(slider.container, 0);\n      return;\n    }\n\n    // Special case: Add 2 clones if slider only has 2\n    // slides and the infinite carousel effect is used.\n    if (!o.rewind && nrOfSlides === 2) {\n      const container = slider.container,\n        children = container.children;\n      container.appendChild(children[0].cloneNode(1));\n      container.appendChild(children[nrOfSlides - 1].cloneNode(1));\n      nrOfSlides += 2;\n      nrOfClones = 2;\n    }\n\n    // Make utilities\n    u = makeUtilities();\n    // Round slide speed to nearest 10th to work with raf animation loop design\n    o.slideSpeed = o.slideSpeed < 2 ? 2 : Math.ceil(o.slideSpeed / 10) * 10;\n\n\n    forEachSlide(function(i) {\n      // Cache slides\n      this.slides.push(this.container.children[i]);\n\n      // Prevent slider from breaking when tabbing during slide\n      // transition which alters scrollLeft. Set scrollLeft to\n      // 0 and slide to focused slide instead.\n      addEvent(this.slides[i], 'focus', (e) => {\n        stopSlideshow();\n        _this.scrollLeft = 0;\n        setPosition(i);\n      }, true);\n\n      if (o.dots) {\n        const newDot = document.createElement('li');\n\n        ((dot, nr) => {\n          // Don't create dots for clones\n          if (nr >= nrOfSlides - nrOfClones) return;\n\n          // Make dots tabbable with \"tabindex\"\n          addClass(dot, classes.dotItem);\n          dot.setAttribute('tabindex', 0);\n          dot.setAttribute('role', 'button');\n\n          dot.innerHTML = '<span></span>';\n\n          // Remove outlines from dots when clicked\n          addEvent(dot, 'click', (e) => {\n            setPosition(nr, true);\n            //dot.blur();\n          });\n\n          // Don't remove outlines when tabbing and Enter\n          // key is used to navigate with dots.\n          addEvent(dot, 'keyup', (e) => {\n            e.keyCode === 13 && setPosition(nr, true);\n          });\n\n          dotFrag.appendChild(dot);\n        })(newDot, i);\n\n        // Cache dots\n        this.dots.push(newDot);\n\n        // Add dots to slider or given dotContainer element\n        if (u.isLastSlide(i)) {\n          this.dotWrap = o.dotContainer || document.createElement('ul');\n          this.dotWrap.appendChild(dotFrag);\n\n          // Only add classname to dot container and\n          // append it to slider if it's generated\n          if (!o.dotContainer) {\n            addClass(this.dotWrap, classes.dotWrap);\n            _this.appendChild(this.dotWrap);\n          }\n        }\n      }\n    });\n\n    // Listen for window resize events\n    addEvent(window, 'resize', onWidthChange);\n    addEvent(window, 'orientationchange', onWidthChange);\n\n    // Listen for touch events\n    touchInit();\n    setupSlider();\n\n    o.mouseDrag && addClass(slider.container, classes.mouseDrag);\n    o.slideShow && startSlideshow();\n\n    // API Callback after setup, expose API first with timeout\n    o.onSetup && setTimeout(() => o.onSetup(nrOfSlides), 0);\n  }\n\n\n  // Init\n  setup();\n\n\n  // Expose slider API\n  return {\n    next,\n    prev,\n    stop: stopSlideshow,\n    start: startSlideshow,\n    setupSlider: (slideNr) => setupSlider(slideNr),\n    moveTo: (slideNr, speed) => setPosition(slideNr, true, speed)\n  };\n}\n","(function() {\r\n  var lastTime = 0;\r\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\r\n    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\r\n  }\r\n\r\n  if (!window.requestAnimationFrame)\r\n    window.requestAnimationFrame = function(callback, element) {\r\n      var currTime = new Date().getTime();\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n      var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\r\n      lastTime = currTime + timeToCall;\r\n      return id;\r\n    };\r\n\r\n  if (!window.cancelAnimationFrame)\r\n    window.cancelAnimationFrame = function(id) {\r\n      clearTimeout(id);\r\n    };\r\n}());","/*!\n * Event Burrito is a touch / mouse / pointer event unifier\n * https://github.com/wilddeer/Event-Burrito\n * Copyright Oleg Korsunsky | http://wd.dizaina.net/\n *\n * MIT License\n *\n * NOTE: Event Burrito has been modified from\n * its original form to suit this project.\n */\n\n/* exported TouchEvents */\nfunction TouchEvents(_this, options) {\n  'use strict';\n\n  const touchStateCallback = () => {},\n    o = {\n      preventDefault: true,\n      clicksAllowed: true,\n      mouse: true,\n      dragThreshold: 10, // Minimum distance to determine swipe direction\n      start: touchStateCallback,\n      move: touchStateCallback,\n      end: touchStateCallback\n    };\n        \n  // Merge user options into defaults\n  options && mergeObjects(o, options);\n\n  let start = {},\n    diff = {},\n    direction,\n    eventType,\n    axis,\n    support = {\n      pointerEvents: !!window.navigator.pointerEnabled,\n      msPointerEvents: !!window.navigator.msPointerEnabled\n    },\n    eventModel = (support.pointerEvents ? 1 : (support.msPointerEvents ? 2 : 0)),\n    events = [\n      ['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events\n      ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events\n      ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events\n      ['mousedown', 'mousemove', 'mouseup', false] //mouse events\n    ],\n    checks = [\n      //touch events\n      (e) =>{\n        //skip the event if it's multitouch or pinch move\n        return (e.touches && e.touches.length > 1) || (e.scale && e.scale !== 1);\n      },\n      //pointer events\n      (e) => {\n        //Skip it, if:\n        //1. event is not primary (other pointers during multitouch),\n        //2. left mouse button is not pressed,\n        //3. mouse drag is disabled and event is not touch\n        return !e.isPrimary || (e.buttons && e.buttons !== 1) || (!o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen');\n      },\n      //IE10 pointer events\n      (e) => {\n        //same checks as in pointer events\n        return !e.isPrimary || (e.buttons && e.buttons !== 1) || (!o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN);\n      },\n      //mouse events\n      (e) => {\n        //skip the event if left mouse button is not pressed\n        //in IE7-8 `buttons` is not defined, in IE9 LMB is 0\n        return (e.buttons && e.buttons !== 1);\n      }\n    ];\n\n\n  function mergeObjects(targetObj, sourceObject) {\n    for (let key in sourceObject) {\n      if (sourceObject.hasOwnProperty(key)) {\n        targetObj[key] = sourceObject[key];\n      }\n    }\n  }\n\n\n  function addEvent(el, event, func, bool) {\n    if (!event) return;\n    el.addEventListener(event, func, !!bool);\n  }\n\n\n  function removeEvent(el, event, func, bool) {\n    if (!event) return;\n    el.removeEventListener(event, func, !!bool);\n  }\n\n\n  function preventDefault(event) {\n    event.preventDefault ? event.preventDefault() : event.returnValue = false;\n  }\n\n\n  function getDiff(event) {\n    diff = {\n      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,\n      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,\n      time: new Date().getTime() - start.time\n    };\n  }\n\n\n  function touchStart(event, type) {\n    direction = '';\n    o.clicksAllowed = true;\n    eventType = type;\n\n    if (checks[eventType](event)) return;\n    if (preventDefault && eventType) preventDefault(event);\n\n    addEvent(document, events[eventType][1], touchMove);\n    addEvent(document, events[eventType][2], touchEnd);\n    addEvent(document, events[eventType][3], touchEnd);\n\n    start = {\n      X: eventType ? event.clientX : event.touches[0].clientX,\n      Y: eventType ? event.clientY : event.touches[0].clientY,\n      time: new Date().getTime()\n    };\n\n    for (let key in diff) {\n      diff[key] = 0;\n    }\n    o.start(event);\n  }\n\n\n  function touchMove(event) {\n    getDiff(event);\n\n    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.\n    document[`on${events[eventType][1]}`] = (e) => { preventDefault(e); };\n\n    if (!axis) {\n      axis = (o.dragThreshold < Math.abs(diff.X)) ? 'X' : (o.dragThreshold < Math.abs(diff.Y)) ? 'Y' : false;\n    } else {\n      if (axis === 'X') {\n        direction = (diff.X < 0) ? 'left' : 'right';\n        preventDefault && preventDefault(event);\n      } else if (axis === 'Y') {\n        direction = (diff.Y < 0) ? 'up' : 'down';\n      }\n    }\n\n    o.move(event, direction, diff);\n  }\n\n\n  function touchEnd(event) {\n    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();\n\n    removeEvent(document, events[eventType][1], touchMove);\n    removeEvent(document, events[eventType][2], touchEnd);\n    removeEvent(document, events[eventType][3], touchEnd);\n\n    //Enable document scrolling\n    document[`on${events[eventType][1]}`] = (e) => { return true; };\n\n    o.end(event, direction, diff);\n    axis = false;\n  }\n\n\n  function init() {\n    // Bind touchstart\n    addEvent(_this, events[eventModel][0], (event) => {\n      touchStart(event, eventModel); \n    });\n    // Prevent stuff from dragging when using mouse\n    addEvent(_this, 'dragstart', preventDefault);\n    \n    // Bind mousedown if necessary\n    if (o.mouse && !eventModel) {\n      addEvent(_this, events[3][0], (event) => {\n        touchStart(event, 3);\n      });\n    }\n\n    // No clicking during touch\n    addEvent(_this, 'click', (event) => {\n      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);\n    });\n  }\n\n  // Init touch listeners\n  init();\n}"]}